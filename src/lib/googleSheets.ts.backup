import { google } from 'googleapis';
import { User, Document } from '@/types';
import { log } from './secureLogger';

// Google Sheets API 인증 설정
const auth = new google.auth.GoogleAuth({
  credentials: {
    client_email: process.env.GOOGLE_SERVICE_ACCOUNT_EMAIL,
    private_key: process.env.GOOGLE_PRIVATE_KEY?.replace(/\\n/g, '\n'),
  },
  scopes: [
    'https://www.googleapis.com/auth/spreadsheets',
    'https://www.googleapis.com/auth/drive.file', // 개인 스프레드시트 생성용
    'https://www.googleapis.com/auth/script.projects', // Google Apps Script API용
  ],
});

const sheets = google.sheets({ version: 'v4', auth });
const drive = google.drive({ version: 'v3', auth });

const MAIN_SPREADSHEET_ID = process.env.MAIN_SPREADSHEET_ID || '';

export class GoogleSheetsService {
  // 이미지 URL 캐시 (메모리 기반)
  private static imageUrlCache = new Map<string, string>();
  
  // API 요청 제한을 위한 플래그
  private static isRateLimited = false;
  // 메인 스프레드시트에서 사용자 조회 (비밀번호 포함)
  static async getUserByLoginId(loginId: string): Promise<(User & { hashedPassword?: string }) | null> {
    try {
      // 먼저 회원정보 시트가 있는지 확인하고 없으면 생성
      await this.ensureMemberInfoSheetExists();
      
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '회원정보!A:G', // 회원정보 시트의 A(사원번호) ~ G(비밀번호)
      });

      const rows = response.data.values || [];
      
      // 헤더 행 제외하고 검색
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const [employeeNumber, name, personalSheetId, username, email, joinDate, hashedPassword] = row;
        
        // 아이디 또는 이메일로 매칭
        if (username === loginId || email === loginId) {
          return {
            employeeNumber,
            name,
            username,
            email,
            joinDate,
            status: 'active',
            personalSheetId,
            hashedPassword,
          };
        }
      }
      
      return null;
    } catch (error) {
      log.error('Error fetching user', error as Error, { loginId });
      throw new Error('사용자 조회 중 오류가 발생했습니다.');
    }
  }

  // 메인 스프레드시트에 새 사용자 추가
  static async createUser(userData: {
    employeeNumber: string;
    name: string;
    username: string;
    email: string;
    personalSheetId: string;
    hashedPassword: string;
  }): Promise<void> {
    try {
      const joinDate = new Date().toISOString().split('T')[0];
      
      // 먼저 '회원정보' 시트가 있는지 확인하고 없으면 생성
      await this.ensureMemberInfoSheetExists();

      const response = await sheets.spreadsheets.values.append({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '회원정보!A:G', // 회원정보 시트의 G열에 비밀번호 추가
        valueInputOption: 'RAW',
        requestBody: {
          values: [[
            userData.employeeNumber,
            userData.name,
            userData.personalSheetId,
            userData.username,
            userData.email,
            joinDate,
            userData.hashedPassword,
          ]],
        },
      });

      log.info('User created successfully', { userId: userData.username });
    } catch (error) {
      log.error('Error creating user', error as Error, { username: userData.username });
      throw new Error('사용자 생성 중 오류가 발생했습니다.');
    }
  }

  // 기존 개인 스프레드시트 ID를 이름으로 찾기
  static async getPersonalSheetIdByName(userName: string): Promise<string | null> {
    try {
      log.debug('Personal spreadsheet ID search started', { userName });
      
      // "문서ID" 시트에서 사용자 이름으로 검색
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '문서ID!A:C', // A, B, C 열 (문서ID, 사용자명, 스프레드시트ID)
      });

      const rows = response.data.values || [];
      log.debug('Document ID sheet rows fetched for personal sheet search', { rowCount: rows.length, userName });

      // 헤더 행 제외하고 검색
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const [documentId, name, spreadsheetId] = row;
        
        log.debug('Processing document ID sheet row', { rowIndex: i, name });
        
        // 사용자 이름과 매칭
        if (name === userName && spreadsheetId) {
          log.info('Personal spreadsheet ID found', { userName, spreadsheetId });
          return spreadsheetId;
        }
      }
      
      log.warn('Personal spreadsheet ID not found', { userName });
      return null;
    } catch (error) {
      log.error('Personal spreadsheet ID search failed', error as Error, { userName });
      throw new Error(`개인 스프레드시트 ID 검색 중 오류가 발생했습니다: ${(error as Error)?.message}`);
    }
  }

  // 사용자의 개인 스프레드시트 ID를 메인 시트에 업데이트
  static async updateUserPersonalSheetId(username: string, personalSheetId: string): Promise<void> {
    try {
      log.debug('Starting personal spreadsheet ID update', { username });
      
      // "회원정보" 시트에서 사용자 찾기
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '회원정보!A:H', // 모든 열 가져오기
      });

      const rows = response.data.values || [];
      
      // 사용자 찾기 (E열이 username)
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const rowUsername = row[4]; // E열: 사용자명
        
        if (rowUsername === username) {
          log.debug('User found for update', { rowIndex: i + 1, username });
          
          // C열(personalSheetId) 업데이트
          await sheets.spreadsheets.values.update({
            spreadsheetId: MAIN_SPREADSHEET_ID,
            range: `회원정보!C${i + 1}`, // C열의 해당 행
            valueInputOption: 'RAW',
            requestBody: {
              values: [[personalSheetId]]
            }
          });
          
          log.info('Personal spreadsheet ID updated successfully', { username });
          return;
        }
      }
      
      log.warn('User not found for spreadsheet ID update', { username });
    } catch (error) {
      log.error('Personal spreadsheet ID update failed', error as Error, { username });
      throw new Error(`개인 스프레드시트 ID 업데이트 중 오류가 발생했습니다: ${(error as Error)?.message}`);
    }
  }

  // 개인 스프레드시트 생성 (사용하지 않음 - 기존 시트 사용)
  static async createPersonalSheet(employeeNumber: string): Promise<string> {
    // 이 메서드는 더 이상 사용하지 않음
    throw new Error('개인 스프레드시트는 이미 생성되어 있습니다. getPersonalSheetIdByName()을 사용하세요.');
  }

  // 개인 스프레드시트에서 미서명 문서 조회 (PRD 구조에 맞게)
  static async getUnsignedDocuments(sheetId: string, useAdvancedImageExtraction = false): Promise<Document[]> {
    try {
      log.debug('Starting unsigned documents retrieval', { sheetId });
      
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: sheetId,
        range: 'A:O', // A(날짜) ~ O(문서링크) - PRD 구조
        valueRenderOption: 'UNFORMATTED_VALUE', // 포맷되지 않은 원본 값
        dateTimeRenderOption: 'FORMATTED_STRING'
      });

      const rows = response.data.values || [];
      const documents: Document[] = [];
      const uncompleteRows: Array<{row: any[], index: number}> = [];
      
      log.debug('Rows fetched from spreadsheet', { rowCount: rows.length });

      // 1단계: 미완료 문서 필터링
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const isCompleted = row[11] || ''; // L: 완료체크
        
        // 완료되지 않은 문서만 필터링 (L열이 TRUE가 아닌 경우)
        const completedValue = String(isCompleted || '').toLowerCase();
        if (!isCompleted || completedValue !== 'true') {
          uncompleteRows.push({row, index: i});
        }
      }

      log.debug('Incomplete documents found', { count: uncompleteRows.length });

      // 2단계: 이미지 URL 추출
      let batchImageResults = new Map<string, string>();
      
      if (useAdvancedImageExtraction && uncompleteRows.length > 0) {
        // 배치 처리로 이미지 정보 조회
        const imageCells: Array<{rowIndex: number, colIndex: number}> = [];
        
        uncompleteRows.forEach(({index}) => {
          imageCells.push(
            {rowIndex: index, colIndex: 7}, // H열 (팀장서명)
            {rowIndex: index, colIndex: 8}, // I열 (검토서명)
            {rowIndex: index, colIndex: 9}  // J열 (대표서명)
          );
        });

        log.debug('Batch image lookup request', { cellCount: imageCells.length });
        batchImageResults = await this.getBatchImageInfo(sheetId, imageCells);
      }

      // 3단계: 문서 객체 생성
      for (const {row, index} of uncompleteRows) {
        // PRD 구조에 맞게 열 매핑
        const date = row[0] || ''; // A: 날짜
        const title = row[1] || ''; // B: 문서명
        const author = row[2] || ''; // C: 작성자
        const content = row[3] || ''; // D: 내용
        const teamLeaderSig = row[7] || ''; // H: 팀장서명
        const reviewSig = row[8] || ''; // I: 검토서명
        const ceoSig = row[9] || ''; // J: 대표서명
        const documentLink = row[14] || ''; // O: 문서링크
        
        log.debug('Processing document row', { index, title });
        
        // 이미지 URL 결정 (배치 결과 우선, 없으면 직접 추출)
        const teamLeaderImageUrl = batchImageResults.get(`${index}_7`) || GoogleSheetsService.extractImageUrl(teamLeaderSig);
        const reviewImageUrl = batchImageResults.get(`${index}_8`) || GoogleSheetsService.extractImageUrl(reviewSig);
        const ceoImageUrl = batchImageResults.get(`${index}_9`) || GoogleSheetsService.extractImageUrl(ceoSig);
        
        documents.push({
          id: `${sheetId}_${index}`,
          date: date,
          title: title,
          author: author,
          content: content,
          teamLeaderSignature: teamLeaderSig,
          reviewSignature: reviewSig,
          ceoSignature: ceoSig,
          teamLeaderSignatureImage: teamLeaderImageUrl,
          reviewSignatureImage: reviewImageUrl,
          ceoSignatureImage: ceoImageUrl,
          isCompleted: false,
          documentLink: documentLink, // O열의 문서 링크
        });
      }

      log.info('Unsigned documents retrieved', { count: documents.length });
      return documents;
    } catch (error) {
      log.error('Failed to retrieve unsigned documents', error as Error, { sheetId });
      throw new Error(`문서 조회 중 오류가 발생했습니다: ${(error as Error)?.message}`);
    }
  }

  // 셀 메타데이터에서 이미지 정보 확인 (필요시에만 사용하는 최적화된 버전)
  private static async getCellImageInfo(sheetId: string, rowIndex: number, colIndex: number): Promise<string | undefined> {
    try {
      log.debug('Cell image info lookup', { sheetId, rowIndex, colIndex });
      
      // API 호출 최소화를 위해 더 작은 범위로 요청
      const spreadsheet = await sheets.spreadsheets.get({
        spreadsheetId: sheetId,
        ranges: [`R${rowIndex + 1}C${colIndex + 1}`],
        includeGridData: true,
        // 필요한 필드만 요청하여 응답 크기 줄이기
        fields: 'sheets(data(rowData(values(effectiveValue,userEnteredValue,hyperlink,textFormatRuns))))'
      });

      const sheet = spreadsheet.data.sheets?.[0];
      const gridData = sheet?.data?.[0];
      const rowData = gridData?.rowData?.[0];
      const cellData = rowData?.values?.[0];

      if (!cellData) {
        log.debug('No cell data found', { sheetId, rowIndex, colIndex });
        return undefined;
      }

      // 이미지 URL 추출 시도
      const effectiveValue = cellData?.effectiveValue?.stringValue || '';
      const userValue = cellData?.userEnteredValue?.stringValue || '';
      
      // 기본 URL 추출 시도
      let imageUrl = this.extractImageUrl(effectiveValue) || this.extractImageUrl(userValue);
      
      // 하이퍼링크에서 추출 시도
      if (!imageUrl && cellData.hyperlink) {
        imageUrl = this.extractImageUrl(cellData.hyperlink);
      }
      
      // 텍스트 포맷에서 링크 추출 시도
      if (!imageUrl && cellData.textFormatRuns) {
        for (const run of cellData.textFormatRuns) {
          if (run.format?.link?.uri) {
            imageUrl = this.extractImageUrl(run.format.link.uri);
            if (imageUrl) break;
          }
        }
      }
      
      return imageUrl;
    } catch (error) {
      log.error('Cell image info retrieval failed', error as Error, { sheetId, rowIndex, colIndex });
      // API 할당량 오류인 경우 특별 처리
      if ((error as Error)?.message?.includes('quota') || (error as Error)?.message?.includes('rate')) {
        log.warn('Skipping cell metadata lookup due to API quota error', { sheetId, rowIndex, colIndex });
      }
      return undefined;
    }
  }

  // 배치로 이미지 정보 조회 (API 호출 최적화)
  private static async getBatchImageInfo(sheetId: string, cells: Array<{rowIndex: number, colIndex: number}>): Promise<Map<string, string>> {
    const results = new Map<string, string>();
    
    if (this.isRateLimited || cells.length === 0) {
      return results;
    }

    try {
      // 캐시된 결과 먼저 확인
      const uncachedCells = cells.filter(cell => {
        const cacheKey = `${sheetId}_${cell.rowIndex}_${cell.colIndex}`;
        const cached = this.imageUrlCache.get(cacheKey);
        if (cached) {
          results.set(`${cell.rowIndex}_${cell.colIndex}`, cached);
          return false;
        }
        return true;
      });

      if (uncachedCells.length === 0) {
        return results;
      }

      log.debug('Batch image lookup', { uncachedCellCount: uncachedCells.length });

      // 범위를 하나의 요청으로 통합
      const ranges = uncachedCells.map(cell => `R${cell.rowIndex + 1}C${cell.colIndex + 1}`);
      
      const spreadsheet = await sheets.spreadsheets.get({
        spreadsheetId: sheetId,
        ranges: ranges,
        includeGridData: true,
        fields: 'sheets(data(rowData(values(effectiveValue,userEnteredValue,hyperlink,textFormatRuns))))'
      });

      // 각 시트의 데이터 처리
      spreadsheet.data.sheets?.forEach((sheet, sheetIndex) => {
        sheet.data?.forEach((gridData, dataIndex) => {
          gridData.rowData?.forEach((rowData, rowIndex) => {
            rowData.values?.forEach((cellData, colIndex) => {
              const cell = uncachedCells[dataIndex];
              if (!cell) return;

              const effectiveValue = cellData?.effectiveValue?.stringValue || '';
              const userValue = cellData?.userEnteredValue?.stringValue || '';
              
              let imageUrl = this.extractImageUrl(effectiveValue) || this.extractImageUrl(userValue);
              
              if (!imageUrl && cellData.hyperlink) {
                imageUrl = this.extractImageUrl(cellData.hyperlink);
              }
              
              if (!imageUrl && cellData.textFormatRuns) {
                for (const run of cellData.textFormatRuns) {
                  if (run.format?.link?.uri) {
                    imageUrl = this.extractImageUrl(run.format.link.uri);
                    if (imageUrl) break;
                  }
                }
              }

              const resultKey = `${cell.rowIndex}_${cell.colIndex}`;
              const cacheKey = `${sheetId}_${cell.rowIndex}_${cell.colIndex}`;
              
              if (imageUrl) {
                results.set(resultKey, imageUrl);
                this.imageUrlCache.set(cacheKey, imageUrl);
              }
            });
          });
        });
      });

      return results;
    } catch (error) {
      log.error('Batch image lookup failed', error as Error);
      
      // API 할당량 오류 감지
      if ((error as Error)?.message?.includes('quota') || (error as Error)?.message?.includes('rate')) {
        log.warn('Disabling image metadata lookup due to API quota limit');
        this.isRateLimited = true;
        // 5분 후 다시 시도할 수 있도록 타이머 설정
        setTimeout(() => {
          this.isRateLimited = false;
          log.info('API limit released, re-enabling image metadata lookup');
        }, 5 * 60 * 1000);
      }
      
      return results;
    }
  }

  // IMPORTRANGE 함수 결과에서 이미지 URL 추출
  private static extractImageUrl(cellValue: any): string | undefined {
    if (!cellValue) return undefined;
    
    // cellValue가 문자열이 아닌 경우 처리
    if (typeof cellValue !== 'string') {
      log.debug('cellValue is not a string', { type: typeof cellValue, value: cellValue });
      return undefined;
    }
    
    log.debug('Attempting image URL extraction', { cellValue });
    
    // 다양한 Google 이미지 URL 패턴들
    const patterns = [
      // Google Drive 직접 링크
      /https:\/\/drive\.google\.com\/file\/d\/([a-zA-Z0-9_-]+)/i,
      // Google Drive uc 링크  
      /https:\/\/drive\.google\.com\/uc\?id=([a-zA-Z0-9_-]+)/i,
      // Google Docs 이미지
      /https:\/\/docs\.google\.com\/[^\s"']+/i,
      // 일반적인 Google 도메인 이미지
      /https:\/\/[^.\s]*\.google\.com\/[^\s"']+\.(jpg|jpeg|png|gif|webp)/i,
      // 모든 Google 링크
      /https:\/\/[^.\s]*\.google\.com\/[^\s"']+/i
    ];
    
    for (const pattern of patterns) {
      const match = cellValue.match(pattern);
      if (match) {
        let imageUrl = match[0];
        
        // Google Drive 파일 ID가 있는 경우 공개 뷰어 URL로 변환
        const fileIdMatch = imageUrl.match(/\/file\/d\/([a-zA-Z0-9_-]+)|id=([a-zA-Z0-9_-]+)/);
        if (fileIdMatch) {
          const fileId = fileIdMatch[1] || fileIdMatch[2];
          imageUrl = `https://drive.google.com/uc?id=${fileId}&export=view`;
        }
        
        log.debug('Extracted image URL', { imageUrl });
        return imageUrl;
      }
    }
    
    // JSON 형태의 값에서 URL 추출 시도
    try {
      const parsed = JSON.parse(cellValue);
      if (parsed.url || parsed.src || parsed.href) {
        const url = parsed.url || parsed.src || parsed.href;
        log.debug('URL extracted from JSON', { url });
        return url;
      }
    } catch {
      // JSON 파싱 실패는 무시
    }
    
    log.debug('No image URL found');
    return undefined;
  }

  // Drive API를 통한 이미지 추출 시도
  private static async tryExtractImageFromDrive(cellData: any): Promise<string | undefined> {
    try {
      log.debug('Attempting image search via Drive API');
      
      // 셀 데이터에서 이미지 관련 정보 찾기
      const formats = cellData?.effectiveFormat || {};
      const textFormat = formats?.textFormat || {};
      
      // 이미지 ID나 링크 정보가 있는지 확인
      if (textFormat?.link && textFormat.link.uri) {
        log.debug('Link found in text format', { uri: textFormat.link.uri });
        return this.extractImageUrl(textFormat.link.uri);
      }
      
      // 셀에 하이퍼링크가 있는 경우
      if (cellData?.hyperlink) {
        log.debug('Hyperlink found', { hyperlink: cellData.hyperlink });
        return this.extractImageUrl(cellData.hyperlink);
      }
      
      log.debug('No image found via Drive API');
      return undefined;
    } catch (error) {
      log.error('Drive API image extraction failed', error as Error);
      return undefined;
    }
  }

  // 서명 완료 처리 (PRD 구조에 맞게 - L열)
  static async completeSignature(sheetId: string, rowIndex: number): Promise<void> {
    try {
      log.info('Starting signature completion', { sheetId, rowIndex: rowIndex + 1 });
      
      // 먼저 해당 셀을 체크박스로 설정
      await sheets.spreadsheets.batchUpdate({
        spreadsheetId: sheetId,
        requestBody: {
          requests: [
            {
              repeatCell: {
                range: {
                  sheetId: 0, // 첫 번째 시트
                  startRowIndex: rowIndex, // 0-based
                  endRowIndex: rowIndex + 1,
                  startColumnIndex: 11, // L열 (0-based)
                  endColumnIndex: 12,
                },
                cell: {
                  dataValidation: {
                    condition: {
                      type: 'BOOLEAN',
                    },
                  },
                },
                fields: 'dataValidation',
              },
            },
          ],
        },
      });

      // 그 다음 TRUE 값으로 체크 표시
      await sheets.spreadsheets.values.update({
        spreadsheetId: sheetId,
        range: `L${rowIndex + 1}`, // L열 (완료체크) - PRD 구조
        valueInputOption: 'RAW',
        requestBody: {
          values: [[true]], // boolean true로 전송
        },
      });

      // 트리거 함수 수동 호출 (API 업데이트는 트리거를 발동시키지 않으므로)
      await this.triggerSheetFunction(sheetId, rowIndex + 1);

      log.info('Signature completion successful', { rowIndex: rowIndex + 1 });
    } catch (error) {
      log.error('Signature completion failed', error as Error, { sheetId, rowIndex });
      throw new Error('서명 완료 처리 중 오류가 발생했습니다.');
    }
  }

  // 사용자별 스크립트 프로젝트 ID 조회
  static async getScriptIdByName(userName: string): Promise<string | null> {
    try {
      log.debug('Script ID search started', { userName });
      
      // "문서ID" 시트에서 사용자 이름으로 스크립트 ID 검색
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '문서ID!A:D', // A, B, C, D 열 (문서ID, 사용자명, 스프레드시트ID, 스크립트프로젝트ID)
      });

      const rows = response.data.values || [];
      log.debug('Document ID sheet rows fetched for script ID search', { rowCount: rows.length, userName });

      // 헤더 행 제외하고 검색
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const [documentId, name, spreadsheetId, scriptId] = row;
        
        log.debug('Processing script ID row', { rowIndex: i, name });
        
        // 사용자 이름과 매칭
        if (name === userName && scriptId) {
          log.info('Script project ID found', { userName, scriptId });
          return scriptId;
        }
      }
      
      log.warn('Script project ID not found', { userName });
      return null;
    } catch (error) {
      log.error('Script ID search failed', error as Error, { userName });
      return null;
    }
  }

  // Webhook을 통한 Google Apps Script 트리거 호출
  static async triggerSheetFunction(sheetId: string, rowNumber: number): Promise<void> {
    try {
      log.info('Webhook trigger call', { sheetId, rowNumber });
      
      // 먼저 현재 사용자 정보 가져오기 (sheetId로 사용자 찾기)
      const userName = await this.getUserNameBySheetId(sheetId);
      if (!userName) {
        log.warn('User name not found', { sheetId, rowNumber });
        return;
      }

      // 사용자별 웹훅 URL 가져오기 (문서ID 시트의 E열에 웹훅 URL 저장)
      const webhookUrl = await this.getWebhookUrlByName(userName);
      if (!webhookUrl) {
        log.warn('Webhook URL not found', { userName });
        return;
      }

      log.debug('Using webhook URL', { webhookUrl });

      // HTTP POST 요청으로 웹훅 호출
      const response = await fetch(webhookUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          sheetId: sheetId,
          rowNumber: rowNumber,
          userName: userName,
          column: 12, // L열
          value: true
        }),
      });

      if (response.ok) {
        const result = await response.text();
        log.info('Webhook call successful', { result });
      } else {
        log.error('Webhook call failed', undefined, { status: response.status, statusText: response.statusText });
      }
    } catch (error) {
      log.error('Webhook call error', error as Error, { sheetId, rowNumber });
      // 웹훅 호출 실패는 치명적이지 않으므로 에러를 던지지 않음
    }
  }

  // 사용자별 웹훅 URL 조회 (문서ID 시트의 E열)
  static async getWebhookUrlByName(userName: string): Promise<string | null> {
    try {
      log.debug('Webhook URL search started', { userName });
      
      // "문서ID" 시트에서 사용자 이름으로 웹훅 URL 검색
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '문서ID!A:E', // A, B, C, D, E 열 (문서ID, 사용자명, 스프레드시트ID, 스크립트프로젝트ID, 웹훅URL)
      });

      const rows = response.data.values || [];
      log.debug('Document ID sheet rows fetched for webhook URL search', { rowCount: rows.length, userName });

      // 헤더 행 제외하고 검색
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const [documentId, name, spreadsheetId, scriptId, webhookUrl] = row;
        
        log.debug('Processing webhook URL row', { rowIndex: i, name });
        
        // 사용자 이름과 매칭
        if (name === userName && webhookUrl) {
          log.info('Webhook URL found', { userName, webhookUrl });
          return webhookUrl;
        }
      }
      
      log.warn('Webhook URL not found', { userName });
      return null;
    } catch (error) {
      log.error('Webhook URL search failed', error as Error, { userName });
      return null;
    }
  }

  // 스프레드시트 ID로 사용자 이름 찾기
  static async getUserNameBySheetId(sheetId: string): Promise<string | null> {
    try {
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '문서ID!A:C',
      });

      const rows = response.data.values || [];
      
      for (let i = 1; i < rows.length; i++) {
        const row = rows[i];
        const [documentId, name, spreadsheetId] = row;
        
        if (spreadsheetId === sheetId) {
          return name;
        }
      }
      
      return null;
    } catch (error) {
      log.error('User name search failed', error as Error, { sheetId });
      return null;
    }
  }

  // 스프레드시트의 특정 범위 데이터 가져오기 (미리보기용)
  static async getSheetData(sheetId: string, range: string): Promise<any[][]> {
    try {
      log.debug('Spreadsheet data query', { sheetId, range });
      
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: sheetId,
        range: range,
        valueRenderOption: 'FORMATTED_VALUE', // 포맷된 값으로 가져오기
        dateTimeRenderOption: 'FORMATTED_STRING'
      });

      const rows = response.data.values || [];
      log.debug('Rows retrieved', { rowCount: rows.length });
      
      return rows;
    } catch (error) {
      log.error('Spreadsheet data retrieval failed', error as Error, { sheetId, range });
      throw new Error('스프레드시트 데이터를 가져올 수 없습니다.');
    }
  }

  // GID로 특정 시트의 데이터 가져오기
  static async getSheetDataByGid(sheetId: string, gid: string, range: string): Promise<any[][]> {
    try {
      log.debug('GID-based spreadsheet data query', { sheetId, gid, range });
      
      // 먼저 스프레드시트 메타데이터를 가져와서 시트 이름 찾기
      const spreadsheet = await sheets.spreadsheets.get({
        spreadsheetId: sheetId,
      });

      const targetSheet = spreadsheet.data.sheets?.find(
        sheet => sheet.properties?.sheetId?.toString() === gid
      );

      if (!targetSheet) {
        throw new Error(`GID ${gid}에 해당하는 시트를 찾을 수 없습니다.`);
      }

      const sheetName = targetSheet.properties?.title || 'Unknown';
      log.debug('Found sheet name', { sheetName });

      // 시트명과 범위를 조합하여 데이터 가져오기
      const fullRange = `${sheetName}!${range}`;
      log.debug('Full range', { fullRange });

      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: sheetId,
        range: fullRange,
        valueRenderOption: 'FORMATTED_VALUE',
        dateTimeRenderOption: 'FORMATTED_STRING'
      });

      const rows = response.data.values || [];
      log.debug('GID-based rows retrieved', { rowCount: rows.length });
      
      return rows;
    } catch (error) {
      log.error('GID-based spreadsheet data retrieval failed', error as Error, { sheetId, gid, range });
      throw new Error('GID로 스프레드시트 데이터를 가져올 수 없습니다.');
    }
  }

  // 아이디 중복 확인
  static async checkUsernameExists(username: string): Promise<boolean> {
    try {
      const user = await this.getUserByLoginId(username);
      return user !== null;
    } catch (error) {
      log.error('Username check failed', error as Error, { username });
      return false;
    }
  }

  // 이메일 중복 확인
  static async checkEmailExists(email: string): Promise<boolean> {
    try {
      const user = await this.getUserByLoginId(email);
      return user !== null;
    } catch (error) {
      log.error('Email check failed', error as Error, { email });
      return false;
    }
  }

  // 최신 사원번호 조회
  static async getLastEmployeeNumber(): Promise<string | null> {
    try {
      // 먼저 회원정보 시트가 있는지 확인하고 없으면 생성
      await this.ensureMemberInfoSheetExists();
      
      const response = await sheets.spreadsheets.values.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
        range: '회원정보!A:A',
      });

      const rows = response.data.values || [];
      let lastNumber = '';

      // 헤더 행 제외하고 마지막 사원번호 찾기
      for (let i = 1; i < rows.length; i++) {
        const employeeNumber = rows[i][0];
        if (employeeNumber && employeeNumber.startsWith('EMP')) {
          lastNumber = employeeNumber;
        }
      }

      return lastNumber || null;
    } catch (error) {
      log.error('Last employee number fetch failed', error as Error);
      return null;
    }
  }

  // '회원정보' 시트가 존재하는지 확인하고 없으면 생성
  static async ensureMemberInfoSheetExists(): Promise<void> {
    try {
      // 먼저 시트 목록을 가져와서 '회원정보' 시트가 있는지 확인
      const spreadsheet = await sheets.spreadsheets.get({
        spreadsheetId: MAIN_SPREADSHEET_ID,
      });

      const existingSheets = spreadsheet.data.sheets || [];
      const memberInfoSheetExists = existingSheets.some(
        sheet => sheet.properties?.title === '회원정보'
      );

      if (!memberInfoSheetExists) {
        // '회원정보' 시트 생성
        await sheets.spreadsheets.batchUpdate({
          spreadsheetId: MAIN_SPREADSHEET_ID,
          requestBody: {
            requests: [
              {
                addSheet: {
                  properties: {
                    title: '회원정보',
                  },
                },
              },
            ],
          },
        });

        // 헤더 행 추가
        await sheets.spreadsheets.values.update({
          spreadsheetId: MAIN_SPREADSHEET_ID,
          range: '회원정보!A1:G1',
          valueInputOption: 'RAW',
          requestBody: {
            values: [[
              '사원번호',
              '사용자명',
              '개인스프레드시트ID',
              '아이디',
              '이메일',
              '가입일',
              '비밀번호'
            ]],
          },
        });

        log.info('Member info sheet created successfully');
      }
    } catch (error) {
      log.error('Member info sheet creation failed', error as Error);
      throw new Error('회원정보 시트 생성 중 오류가 발생했습니다.');
    }
  }
}